\documentclass[../../Rapport RayTracer.tex]{subfiles}


\begin{document}

\label{multithreading}
Les algorithmes de ray tracing sont réputés pour être lents à exécuter. Cependant, chaque pixel pouvant être calculé totalement indépendemment des autres,
ces algorithmes sont des cibles parfaites pour la parallélisation de calcul. Nous avons donc mis en place, afin d'accélérer les temps de rendu, un multithreading de
l'application grâce aux threads de Java. Pour ce faire, nous découpons l'image à rendre en plusieurs "tuiles". Nous construisons ensuite une tâche à partir de chaque tuile.
Une tâche consistant en:
\begin{itemize}
	\item{Un pixel de départ X et Y sur l'image à rendre}	
	\item{Un pixel d'arrivée X et Y sur l'image à rendre}
\end{itemize}
A partir de toutes ces tâches isolées est ensuite construite une liste de tâche. Cette dernière servira aux threads. Ils viendront en effet piocher dans la liste afin de récupérer les informations sur la zone de l'image qu'ils ont à rendre.
Un diagramme présente le package multithreading dans la section \ref{packageMultithreading}.

Afin d'éviter les situations de concurrences entre les threads, la plupart des méthodes de la classe \textit{ThreadsTaskList} sont \textit{\textbf{synchronized}}. Grâce à ce mot clé, seulement un thread du programme peut accéder à la méthode à un instant t et nous évitons ainsi les problèmes de concurrence.

\end{document}